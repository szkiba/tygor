// Code generated by tygor; DO NOT EDIT.

// xk6-faker random fake data generator
package faker

import (
	"errors"
	"fmt"
	"github.com/dop251/goja"
	"go.k6.io/k6/js/modules"
	"time"
)

// k6Module represents k6 JavaScript extension module.
type k6Module struct {
	goModuleConstructor goModuleConstructor
}

// NewModuleInstance creates new per VU module instance.
func (m *k6Module) NewModuleInstance(vu modules.VU) modules.Instance {
	mi := new(k6ModuleInstance)
	adaptee := m.goModuleConstructor(vu)
	adapter := jsModuleFrom(adaptee)

	vm := vu.Runtime()

	dict := make(map[string]interface{})

	dict["Faker"] = vm.ToValue(newFakerConstructor(adaptee.newFaker))

	mi.exports.Named = dict

	obj := adapter.fakerGetter(goja.FunctionCall{This: goja.Undefined()}, vm).ToObject(vm)

	mi.exports.Default = obj

	return mi
}

// register registers k6 JavaScript extension module.
func register(ctor goModuleConstructor) {
	m := new(k6Module)
	m.goModuleConstructor = ctor
	modules.Register("k6/x/faker", m)
}

// k6ModuleInstance represents per VU module instance.
type k6ModuleInstance struct {
	exports modules.Exports
}

// Exports returns exported symbols.
func (mi *k6ModuleInstance) Exports() modules.Exports {
	return mi.exports
}

// jsModule is the go binding for the JavaScript Module type.
//
// TSDoc:
// xk6-faker random fake data generator
type jsModule interface {
	// fakerGetter is the go getter binding for the JavaScript faker property.
	//
	// TSDoc:
	// Default Faker instance.
	fakerGetter(call goja.FunctionCall, vm *goja.Runtime) goja.Value
}

// jsModuleAdapter converts goModule to jsModule.
type jsModuleAdapter struct {
	adaptee goModule
}

var _ jsModule = (*jsModuleAdapter)(nil)

// fakerGetter is a jsModule property getter adapter method.
func (self *jsModuleAdapter) fakerGetter(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.fakerGetter()
	if err != nil {
		panic(err)
	}

	return goFakerToObject(v, vm)
}

// jsModuleFrom returns a jsModule based on a goModule.
func jsModuleFrom(adaptee goModule) jsModule {
	return &jsModuleAdapter{adaptee: adaptee}
}

// goModule is the go representation of the JavaScript Module type.
//
// TSDoc:
// xk6-faker random fake data generator
type goModule interface {
	// newFaker is the go factory method for the Faker type.
	newFaker(seedArg int64) (goFaker, error)

	// fakerGetter is the go getter method for the faker property.
	//
	// TSDoc:
	// Default Faker instance.
	fakerGetter() (goFaker, error)
}

// goModuleConstructor creates new goModule instance.
type goModuleConstructor func(vu modules.VU) goModule

// jsFaker is the go binding for the JavaScript Faker type.
//
// TSDoc:
// This is Faker's main class containing all modules that can be used to generate data.
//
// Please have a look at the individual modules and methods for more information and examples.
type jsFaker interface {
	// personGetter is the go getter binding for the JavaScript person property.
	//
	// TSDoc:
	// API to generate people's personal information such as names and job titles.
	personGetter(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// companyGetter is the go getter binding for the JavaScript company property.
	//
	// TSDoc:
	// API to generate company related entries.
	companyGetter(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// hackerGetter is the go getter binding for the JavaScript hacker property.
	//
	// TSDoc:
	// API to generate hacker/IT words and phrases.
	hackerGetter(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// hipsterGetter is the go getter binding for the JavaScript hipster property.
	//
	// TSDoc:
	// API to generate hipster words, phrases and paragraphs.
	hipsterGetter(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// loremGetter is the go getter binding for the JavaScript lorem property.
	//
	// TSDoc:
	// API to generate random words, sentences, paragraphs, questions and quotes.
	loremGetter(call goja.FunctionCall, vm *goja.Runtime) goja.Value
}

// goFaker is the go representation of the JavaScript Faker type.
//
// TSDoc:
// This is Faker's main class containing all modules that can be used to generate data.
//
// Please have a look at the individual modules and methods for more information and examples.
type goFaker interface {
	// personGetter is the go getter method for the person property.
	//
	// TSDoc:
	// API to generate people's personal information such as names and job titles.
	personGetter() (goPerson, error)

	// companyGetter is the go getter method for the company property.
	//
	// TSDoc:
	// API to generate company related entries.
	companyGetter() (goCompany, error)

	// hackerGetter is the go getter method for the hacker property.
	//
	// TSDoc:
	// API to generate hacker/IT words and phrases.
	hackerGetter() (goHacker, error)

	// hipsterGetter is the go getter method for the hipster property.
	//
	// TSDoc:
	// API to generate hipster words, phrases and paragraphs.
	hipsterGetter() (goHipster, error)

	// loremGetter is the go getter method for the lorem property.
	//
	// TSDoc:
	// API to generate random words, sentences, paragraphs, questions and quotes.
	loremGetter() (goLorem, error)
}

// jsFakerAdapter converts goFaker to jsFaker.
type jsFakerAdapter struct {
	adaptee goFaker
}

var _ jsFaker = (*jsFakerAdapter)(nil)

// personGetter is a jsFaker property getter adapter method.
func (self *jsFakerAdapter) personGetter(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.personGetter()
	if err != nil {
		panic(err)
	}

	return goPersonToObject(v, vm)
}

// companyGetter is a jsFaker property getter adapter method.
func (self *jsFakerAdapter) companyGetter(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.companyGetter()
	if err != nil {
		panic(err)
	}

	return goCompanyToObject(v, vm)
}

// hackerGetter is a jsFaker property getter adapter method.
func (self *jsFakerAdapter) hackerGetter(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.hackerGetter()
	if err != nil {
		panic(err)
	}

	return goHackerToObject(v, vm)
}

// hipsterGetter is a jsFaker property getter adapter method.
func (self *jsFakerAdapter) hipsterGetter(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.hipsterGetter()
	if err != nil {
		panic(err)
	}

	return goHipsterToObject(v, vm)
}

// loremGetter is a jsFaker property getter adapter method.
func (self *jsFakerAdapter) loremGetter(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.loremGetter()
	if err != nil {
		panic(err)
	}

	return goLoremToObject(v, vm)
}

// goFakerAdapter converts goja Object to goFaker.
type goFakerAdapter struct {
	adaptee *goja.Object
	vm      *goja.Runtime
}

var _ goFaker = (*goFakerAdapter)(nil)

// personGetter is a goFaker property getter adapter method.
func (self *goFakerAdapter) personGetter() (goPerson, error) {
	return self.adaptee.Get("person").Export().(goPerson), nil
}

// companyGetter is a goFaker property getter adapter method.
func (self *goFakerAdapter) companyGetter() (goCompany, error) {
	return self.adaptee.Get("company").Export().(goCompany), nil
}

// hackerGetter is a goFaker property getter adapter method.
func (self *goFakerAdapter) hackerGetter() (goHacker, error) {
	return self.adaptee.Get("hacker").Export().(goHacker), nil
}

// hipsterGetter is a goFaker property getter adapter method.
func (self *goFakerAdapter) hipsterGetter() (goHipster, error) {
	return self.adaptee.Get("hipster").Export().(goHipster), nil
}

// loremGetter is a goFaker property getter adapter method.
func (self *goFakerAdapter) loremGetter() (goLorem, error) {
	return self.adaptee.Get("lorem").Export().(goLorem), nil
}

// jsFakerTo setup Faker JavaScript object from jsFaker.
func jsFakerTo(src jsFaker, obj *goja.Object, vm *goja.Runtime) error {
	if err := obj.DefineAccessorProperty("person", vm.ToValue(src.personGetter), goja.Undefined(), goja.FLAG_FALSE, goja.FLAG_TRUE); err != nil {
		return err
	}

	if err := obj.DefineAccessorProperty("company", vm.ToValue(src.companyGetter), goja.Undefined(), goja.FLAG_FALSE, goja.FLAG_TRUE); err != nil {
		return err
	}

	if err := obj.DefineAccessorProperty("hacker", vm.ToValue(src.hackerGetter), goja.Undefined(), goja.FLAG_FALSE, goja.FLAG_TRUE); err != nil {
		return err
	}

	if err := obj.DefineAccessorProperty("hipster", vm.ToValue(src.hipsterGetter), goja.Undefined(), goja.FLAG_FALSE, goja.FLAG_TRUE); err != nil {
		return err
	}

	return obj.DefineAccessorProperty("lorem", vm.ToValue(src.loremGetter), goja.Undefined(), goja.FLAG_FALSE, goja.FLAG_TRUE)
}

// jsFakerFrom returns a jsFaker based on a goFaker.
func jsFakerFrom(adaptee goFaker) jsFaker {
	return &jsFakerAdapter{adaptee: adaptee}
}

// goFakerFrom returns a goFaker from goja Object.
func goFakerFrom(adaptee *goja.Object, vm *goja.Runtime) goFaker {
	return &goFakerAdapter{adaptee: adaptee, vm: vm}
}

// goFakerToObject returns a goja Object from goFaker.
func goFakerToObject(v goFaker, vm *goja.Runtime) *goja.Object {
	obj := vm.NewObject()

	err := jsFakerTo(jsFakerFrom(v), obj, vm)
	if err != nil {
		panic(err)
	}

	return obj
}

// goFakerConstructor creates new goFaker instance.
type goFakerConstructor func(seedArg int64) (goFaker, error)

// newFakerConstructor creates Faker JavaScript constructor.
func newFakerConstructor(ctor goFakerConstructor) func(call goja.ConstructorCall, vm *goja.Runtime) *goja.Object {
	return func(call goja.ConstructorCall, vm *goja.Runtime) *goja.Object {
		adaptee, err := ctor(call.Argument(0).ToInteger())
		if err != nil {
			panic(err)
		}

		adapter := jsFakerFrom(adaptee)

		if err := jsFakerTo(adapter, call.This, vm); err != nil {
			panic(err)
		}

		return nil
	}
}

// jsPerson is the go binding for the JavaScript Person type.
//
// TSDoc:
// API to generate people's personal information such as names and job titles.
type jsPerson interface {
	// firstNameMethod is the go binding for the JavaScript firstName method.
	//
	// TSDoc:
	// Generates a random first name.
	firstNameMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// lastNameMethod is the go binding for the JavaScript lastName method.
	//
	// TSDoc:
	// Generates a random last name.
	lastNameMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// prefixMethod is the go binding for the JavaScript prefix method.
	//
	// TSDoc:
	// Generates a random person prefix.
	prefixMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// suffixMethod is the go binding for the JavaScript suffix method.
	//
	// TSDoc:
	// Generates a random person suffix.
	suffixMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// sexTypeMethod is the go binding for the JavaScript sexType method.
	//
	// TSDoc:
	// Generates a random sex type.
	sexTypeMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// jobTitleMethod is the go binding for the JavaScript jobTitle method.
	//
	// TSDoc:
	// Generates a random job title.
	jobTitleMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// jobLevelMethod is the go binding for the JavaScript jobLevel method.
	//
	// TSDoc:
	// Generates a random job level.
	jobLevelMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// jobDescriptorMethod is the go binding for the JavaScript jobDescriptor method.
	//
	// TSDoc:
	// Generates a random job descriptor.
	jobDescriptorMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value
}

// goPerson is the go representation of the JavaScript Person type.
//
// TSDoc:
// API to generate people's personal information such as names and job titles.
type goPerson interface {
	// firstNameMethod is the go representation of the firstName method.
	//
	// TSDoc:
	// Generates a random first name.
	firstNameMethod() (string, error)

	// lastNameMethod is the go representation of the lastName method.
	//
	// TSDoc:
	// Generates a random last name.
	lastNameMethod() (string, error)

	// prefixMethod is the go representation of the prefix method.
	//
	// TSDoc:
	// Generates a random person prefix.
	prefixMethod() (string, error)

	// suffixMethod is the go representation of the suffix method.
	//
	// TSDoc:
	// Generates a random person suffix.
	suffixMethod() (string, error)

	// sexTypeMethod is the go representation of the sexType method.
	//
	// TSDoc:
	// Generates a random sex type.
	sexTypeMethod() (string, error)

	// jobTitleMethod is the go representation of the jobTitle method.
	//
	// TSDoc:
	// Generates a random job title.
	jobTitleMethod() (string, error)

	// jobLevelMethod is the go representation of the jobLevel method.
	//
	// TSDoc:
	// Generates a random job level.
	jobLevelMethod() (string, error)

	// jobDescriptorMethod is the go representation of the jobDescriptor method.
	//
	// TSDoc:
	// Generates a random job descriptor.
	jobDescriptorMethod() (string, error)
}

// jsPersonAdapter converts goPerson to jsPerson.
type jsPersonAdapter struct {
	adaptee goPerson
}

var _ jsPerson = (*jsPersonAdapter)(nil)

// firstNameMethod is a jsPerson adapter method.
func (self *jsPersonAdapter) firstNameMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.firstNameMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// lastNameMethod is a jsPerson adapter method.
func (self *jsPersonAdapter) lastNameMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.lastNameMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// prefixMethod is a jsPerson adapter method.
func (self *jsPersonAdapter) prefixMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.prefixMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// suffixMethod is a jsPerson adapter method.
func (self *jsPersonAdapter) suffixMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.suffixMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// sexTypeMethod is a jsPerson adapter method.
func (self *jsPersonAdapter) sexTypeMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.sexTypeMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// jobTitleMethod is a jsPerson adapter method.
func (self *jsPersonAdapter) jobTitleMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.jobTitleMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// jobLevelMethod is a jsPerson adapter method.
func (self *jsPersonAdapter) jobLevelMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.jobLevelMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// jobDescriptorMethod is a jsPerson adapter method.
func (self *jsPersonAdapter) jobDescriptorMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.jobDescriptorMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// goPersonAdapter converts goja Object to goPerson.
type goPersonAdapter struct {
	adaptee *goja.Object
	vm      *goja.Runtime
}

var _ goPerson = (*goPersonAdapter)(nil)

// firstNameMethod is a firstName adapter method.
func (self *goPersonAdapter) firstNameMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("firstName"))
	if !ok {
		return "", fmt.Errorf("%w: firstName", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// lastNameMethod is a lastName adapter method.
func (self *goPersonAdapter) lastNameMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("lastName"))
	if !ok {
		return "", fmt.Errorf("%w: lastName", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// prefixMethod is a prefix adapter method.
func (self *goPersonAdapter) prefixMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("prefix"))
	if !ok {
		return "", fmt.Errorf("%w: prefix", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// suffixMethod is a suffix adapter method.
func (self *goPersonAdapter) suffixMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("suffix"))
	if !ok {
		return "", fmt.Errorf("%w: suffix", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// sexTypeMethod is a sexType adapter method.
func (self *goPersonAdapter) sexTypeMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("sexType"))
	if !ok {
		return "", fmt.Errorf("%w: sexType", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// jobTitleMethod is a jobTitle adapter method.
func (self *goPersonAdapter) jobTitleMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("jobTitle"))
	if !ok {
		return "", fmt.Errorf("%w: jobTitle", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// jobLevelMethod is a jobLevel adapter method.
func (self *goPersonAdapter) jobLevelMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("jobLevel"))
	if !ok {
		return "", fmt.Errorf("%w: jobLevel", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// jobDescriptorMethod is a jobDescriptor adapter method.
func (self *goPersonAdapter) jobDescriptorMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("jobDescriptor"))
	if !ok {
		return "", fmt.Errorf("%w: jobDescriptor", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// jsPersonTo setup Person JavaScript object from jsPerson.
func jsPersonTo(src jsPerson, obj *goja.Object, vm *goja.Runtime) error {
	if err := obj.Set("firstName", src.firstNameMethod); err != nil {
		return err
	}

	if err := obj.Set("lastName", src.lastNameMethod); err != nil {
		return err
	}

	if err := obj.Set("prefix", src.prefixMethod); err != nil {
		return err
	}

	if err := obj.Set("suffix", src.suffixMethod); err != nil {
		return err
	}

	if err := obj.Set("sexType", src.sexTypeMethod); err != nil {
		return err
	}

	if err := obj.Set("jobTitle", src.jobTitleMethod); err != nil {
		return err
	}

	if err := obj.Set("jobLevel", src.jobLevelMethod); err != nil {
		return err
	}

	return obj.Set("jobDescriptor", src.jobDescriptorMethod)
}

// jsPersonFrom returns a jsPerson based on a goPerson.
func jsPersonFrom(adaptee goPerson) jsPerson {
	return &jsPersonAdapter{adaptee: adaptee}
}

// goPersonFrom returns a goPerson from goja Object.
func goPersonFrom(adaptee *goja.Object, vm *goja.Runtime) goPerson {
	return &goPersonAdapter{adaptee: adaptee, vm: vm}
}

// goPersonToObject returns a goja Object from goPerson.
func goPersonToObject(v goPerson, vm *goja.Runtime) *goja.Object {
	obj := vm.NewObject()

	err := jsPersonTo(jsPersonFrom(v), obj, vm)
	if err != nil {
		panic(err)
	}

	return obj
}

// jsCompany is the go binding for the JavaScript Company type.
//
// TSDoc:
// API to generate company related entries.
type jsCompany interface {
	// nameMethod is the go binding for the JavaScript name method.
	//
	// TSDoc:
	// Generates a random company name string.
	nameMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// suffixMethod is the go binding for the JavaScript suffix method.
	//
	// TSDoc:
	// Generates a random company suffix string.
	suffixMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// buzzWordMethod is the go binding for the JavaScript buzzWord method.
	//
	// TSDoc:
	// Generates a random company buzz word string.
	buzzWordMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// bsMethod is the go binding for the JavaScript bs method.
	//
	// TSDoc:
	// Generates a random company bs string.
	bsMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value
}

// goCompany is the go representation of the JavaScript Company type.
//
// TSDoc:
// API to generate company related entries.
type goCompany interface {
	// nameMethod is the go representation of the name method.
	//
	// TSDoc:
	// Generates a random company name string.
	nameMethod() (string, error)

	// suffixMethod is the go representation of the suffix method.
	//
	// TSDoc:
	// Generates a random company suffix string.
	suffixMethod() (string, error)

	// buzzWordMethod is the go representation of the buzzWord method.
	//
	// TSDoc:
	// Generates a random company buzz word string.
	buzzWordMethod() (string, error)

	// bsMethod is the go representation of the bs method.
	//
	// TSDoc:
	// Generates a random company bs string.
	bsMethod() (string, error)
}

// jsCompanyAdapter converts goCompany to jsCompany.
type jsCompanyAdapter struct {
	adaptee goCompany
}

var _ jsCompany = (*jsCompanyAdapter)(nil)

// nameMethod is a jsCompany adapter method.
func (self *jsCompanyAdapter) nameMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.nameMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// suffixMethod is a jsCompany adapter method.
func (self *jsCompanyAdapter) suffixMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.suffixMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// buzzWordMethod is a jsCompany adapter method.
func (self *jsCompanyAdapter) buzzWordMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.buzzWordMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// bsMethod is a jsCompany adapter method.
func (self *jsCompanyAdapter) bsMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.bsMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// goCompanyAdapter converts goja Object to goCompany.
type goCompanyAdapter struct {
	adaptee *goja.Object
	vm      *goja.Runtime
}

var _ goCompany = (*goCompanyAdapter)(nil)

// nameMethod is a name adapter method.
func (self *goCompanyAdapter) nameMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("name"))
	if !ok {
		return "", fmt.Errorf("%w: name", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// suffixMethod is a suffix adapter method.
func (self *goCompanyAdapter) suffixMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("suffix"))
	if !ok {
		return "", fmt.Errorf("%w: suffix", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// buzzWordMethod is a buzzWord adapter method.
func (self *goCompanyAdapter) buzzWordMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("buzzWord"))
	if !ok {
		return "", fmt.Errorf("%w: buzzWord", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// bsMethod is a bs adapter method.
func (self *goCompanyAdapter) bsMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("bs"))
	if !ok {
		return "", fmt.Errorf("%w: bs", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// jsCompanyTo setup Company JavaScript object from jsCompany.
func jsCompanyTo(src jsCompany, obj *goja.Object, vm *goja.Runtime) error {
	if err := obj.Set("name", src.nameMethod); err != nil {
		return err
	}

	if err := obj.Set("suffix", src.suffixMethod); err != nil {
		return err
	}

	if err := obj.Set("buzzWord", src.buzzWordMethod); err != nil {
		return err
	}

	return obj.Set("bs", src.bsMethod)
}

// jsCompanyFrom returns a jsCompany based on a goCompany.
func jsCompanyFrom(adaptee goCompany) jsCompany {
	return &jsCompanyAdapter{adaptee: adaptee}
}

// goCompanyFrom returns a goCompany from goja Object.
func goCompanyFrom(adaptee *goja.Object, vm *goja.Runtime) goCompany {
	return &goCompanyAdapter{adaptee: adaptee, vm: vm}
}

// goCompanyToObject returns a goja Object from goCompany.
func goCompanyToObject(v goCompany, vm *goja.Runtime) *goja.Object {
	obj := vm.NewObject()

	err := jsCompanyTo(jsCompanyFrom(v), obj, vm)
	if err != nil {
		panic(err)
	}

	return obj
}

// jsHacker is the go binding for the JavaScript Hacker type.
//
// TSDoc:
// API to generate hacker/IT words and phrases.
type jsHacker interface {
	// abbreviationMethod is the go binding for the JavaScript abbreviation method.
	//
	// TSDoc:
	// Generates a random hacker/IT abbreviation.
	abbreviationMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// adjectiveMethod is the go binding for the JavaScript adjective method.
	//
	// TSDoc:
	// Generates a random hacker/IT adjective.
	adjectiveMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// ingverbMethod is the go binding for the JavaScript ingverb method.
	//
	// TSDoc:
	// Generates a random hacker/IT verb for continuous actions (en: ing suffix; e.g. hacking).
	ingverbMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// nounMethod is the go binding for the JavaScript noun method.
	//
	// TSDoc:
	// Generates a random hacker/IT noun.
	nounMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// phraseMethod is the go binding for the JavaScript phrase method.
	//
	// TSDoc:
	// Generates a random hacker/IT phrase.
	phraseMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// verbMethod is the go binding for the JavaScript verb method.
	//
	// TSDoc:
	// Generates a random hacker/IT verb.
	verbMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value
}

// goHacker is the go representation of the JavaScript Hacker type.
//
// TSDoc:
// API to generate hacker/IT words and phrases.
type goHacker interface {
	// abbreviationMethod is the go representation of the abbreviation method.
	//
	// TSDoc:
	// Generates a random hacker/IT abbreviation.
	abbreviationMethod() (string, error)

	// adjectiveMethod is the go representation of the adjective method.
	//
	// TSDoc:
	// Generates a random hacker/IT adjective.
	adjectiveMethod() (string, error)

	// ingverbMethod is the go representation of the ingverb method.
	//
	// TSDoc:
	// Generates a random hacker/IT verb for continuous actions (en: ing suffix; e.g. hacking).
	ingverbMethod() (string, error)

	// nounMethod is the go representation of the noun method.
	//
	// TSDoc:
	// Generates a random hacker/IT noun.
	nounMethod() (string, error)

	// phraseMethod is the go representation of the phrase method.
	//
	// TSDoc:
	// Generates a random hacker/IT phrase.
	phraseMethod() (string, error)

	// verbMethod is the go representation of the verb method.
	//
	// TSDoc:
	// Generates a random hacker/IT verb.
	verbMethod() (string, error)
}

// jsHackerAdapter converts goHacker to jsHacker.
type jsHackerAdapter struct {
	adaptee goHacker
}

var _ jsHacker = (*jsHackerAdapter)(nil)

// abbreviationMethod is a jsHacker adapter method.
func (self *jsHackerAdapter) abbreviationMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.abbreviationMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// adjectiveMethod is a jsHacker adapter method.
func (self *jsHackerAdapter) adjectiveMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.adjectiveMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// ingverbMethod is a jsHacker adapter method.
func (self *jsHackerAdapter) ingverbMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.ingverbMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// nounMethod is a jsHacker adapter method.
func (self *jsHackerAdapter) nounMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.nounMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// phraseMethod is a jsHacker adapter method.
func (self *jsHackerAdapter) phraseMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.phraseMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// verbMethod is a jsHacker adapter method.
func (self *jsHackerAdapter) verbMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.verbMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// goHackerAdapter converts goja Object to goHacker.
type goHackerAdapter struct {
	adaptee *goja.Object
	vm      *goja.Runtime
}

var _ goHacker = (*goHackerAdapter)(nil)

// abbreviationMethod is a abbreviation adapter method.
func (self *goHackerAdapter) abbreviationMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("abbreviation"))
	if !ok {
		return "", fmt.Errorf("%w: abbreviation", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// adjectiveMethod is a adjective adapter method.
func (self *goHackerAdapter) adjectiveMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("adjective"))
	if !ok {
		return "", fmt.Errorf("%w: adjective", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// ingverbMethod is a ingverb adapter method.
func (self *goHackerAdapter) ingverbMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("ingverb"))
	if !ok {
		return "", fmt.Errorf("%w: ingverb", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// nounMethod is a noun adapter method.
func (self *goHackerAdapter) nounMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("noun"))
	if !ok {
		return "", fmt.Errorf("%w: noun", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// phraseMethod is a phrase adapter method.
func (self *goHackerAdapter) phraseMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("phrase"))
	if !ok {
		return "", fmt.Errorf("%w: phrase", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// verbMethod is a verb adapter method.
func (self *goHackerAdapter) verbMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("verb"))
	if !ok {
		return "", fmt.Errorf("%w: verb", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// jsHackerTo setup Hacker JavaScript object from jsHacker.
func jsHackerTo(src jsHacker, obj *goja.Object, vm *goja.Runtime) error {
	if err := obj.Set("abbreviation", src.abbreviationMethod); err != nil {
		return err
	}

	if err := obj.Set("adjective", src.adjectiveMethod); err != nil {
		return err
	}

	if err := obj.Set("ingverb", src.ingverbMethod); err != nil {
		return err
	}

	if err := obj.Set("noun", src.nounMethod); err != nil {
		return err
	}

	if err := obj.Set("phrase", src.phraseMethod); err != nil {
		return err
	}

	return obj.Set("verb", src.verbMethod)
}

// jsHackerFrom returns a jsHacker based on a goHacker.
func jsHackerFrom(adaptee goHacker) jsHacker {
	return &jsHackerAdapter{adaptee: adaptee}
}

// goHackerFrom returns a goHacker from goja Object.
func goHackerFrom(adaptee *goja.Object, vm *goja.Runtime) goHacker {
	return &goHackerAdapter{adaptee: adaptee, vm: vm}
}

// goHackerToObject returns a goja Object from goHacker.
func goHackerToObject(v goHacker, vm *goja.Runtime) *goja.Object {
	obj := vm.NewObject()

	err := jsHackerTo(jsHackerFrom(v), obj, vm)
	if err != nil {
		panic(err)
	}

	return obj
}

// jsHipster is the go binding for the JavaScript Hipster type.
//
// TSDoc:
// API to generate hipster words, phrases and paragraphs.
type jsHipster interface {
	// wordMethod is the go binding for the JavaScript word method.
	//
	// TSDoc:
	// Generates a single hipster word.
	wordMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// sentenceMethod is the go binding for the JavaScript sentence method.
	//
	// TSDoc:
	// Generates a random hipster sentence.
	sentenceMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// paragraphMethod is the go binding for the JavaScript paragraph method.
	//
	// TSDoc:
	// Generates a random hipster paragraphs.
	paragraphMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value
}

// goHipster is the go representation of the JavaScript Hipster type.
//
// TSDoc:
// API to generate hipster words, phrases and paragraphs.
type goHipster interface {
	// wordMethod is the go representation of the word method.
	//
	// TSDoc:
	// Generates a single hipster word.
	wordMethod() (string, error)

	// sentenceMethod is the go representation of the sentence method.
	//
	// TSDoc:
	// Generates a random hipster sentence.
	sentenceMethod(wordCountArg int) (string, error)

	// paragraphMethod is the go representation of the paragraph method.
	//
	// TSDoc:
	// Generates a random hipster paragraphs.
	paragraphMethod(paragraphCountArg int, sentenceCountArg int, wordCountArg int, separatorArg string) (string, error)
}

// jsHipsterAdapter converts goHipster to jsHipster.
type jsHipsterAdapter struct {
	adaptee goHipster
}

var _ jsHipster = (*jsHipsterAdapter)(nil)

// wordMethod is a jsHipster adapter method.
func (self *jsHipsterAdapter) wordMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.wordMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// sentenceMethod is a jsHipster adapter method.
func (self *jsHipsterAdapter) sentenceMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.sentenceMethod(int(call.Argument(0).ToInteger()))
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// paragraphMethod is a jsHipster adapter method.
func (self *jsHipsterAdapter) paragraphMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.paragraphMethod(int(call.Argument(0).ToInteger()), int(call.Argument(1).ToInteger()), int(call.Argument(2).ToInteger()), call.Argument(3).String())
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// goHipsterAdapter converts goja Object to goHipster.
type goHipsterAdapter struct {
	adaptee *goja.Object
	vm      *goja.Runtime
}

var _ goHipster = (*goHipsterAdapter)(nil)

// wordMethod is a word adapter method.
func (self *goHipsterAdapter) wordMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("word"))
	if !ok {
		return "", fmt.Errorf("%w: word", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// sentenceMethod is a sentence adapter method.
func (self *goHipsterAdapter) sentenceMethod(wordCountArg int) (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("sentence"))
	if !ok {
		return "", fmt.Errorf("%w: sentence", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// paragraphMethod is a paragraph adapter method.
func (self *goHipsterAdapter) paragraphMethod(paragraphCountArg int, sentenceCountArg int, wordCountArg int, separatorArg string) (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("paragraph"))
	if !ok {
		return "", fmt.Errorf("%w: paragraph", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// jsHipsterTo setup Hipster JavaScript object from jsHipster.
func jsHipsterTo(src jsHipster, obj *goja.Object, vm *goja.Runtime) error {
	if err := obj.Set("word", src.wordMethod); err != nil {
		return err
	}

	if err := obj.Set("sentence", src.sentenceMethod); err != nil {
		return err
	}

	return obj.Set("paragraph", src.paragraphMethod)
}

// jsHipsterFrom returns a jsHipster based on a goHipster.
func jsHipsterFrom(adaptee goHipster) jsHipster {
	return &jsHipsterAdapter{adaptee: adaptee}
}

// goHipsterFrom returns a goHipster from goja Object.
func goHipsterFrom(adaptee *goja.Object, vm *goja.Runtime) goHipster {
	return &goHipsterAdapter{adaptee: adaptee, vm: vm}
}

// goHipsterToObject returns a goja Object from goHipster.
func goHipsterToObject(v goHipster, vm *goja.Runtime) *goja.Object {
	obj := vm.NewObject()

	err := jsHipsterTo(jsHipsterFrom(v), obj, vm)
	if err != nil {
		panic(err)
	}

	return obj
}

// jsLorem is the go binding for the JavaScript Lorem type.
//
// TSDoc:
// API to generate random words, sentences, paragraphs, questions and quotes.
type jsLorem interface {
	// paragraphMethod is the go binding for the JavaScript paragraph method.
	//
	// TSDoc:
	// Generates the given number of paragraphs.
	paragraphMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// sentenceMethod is the go binding for the JavaScript sentence method.
	//
	// TSDoc:
	// Generates a space separated list of words beginning with a capital letter and ending with a period.
	sentenceMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// wordMethod is the go binding for the JavaScript word method.
	//
	// TSDoc:
	// Generates a random word.
	wordMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// questionMethod is the go binding for the JavaScript question method.
	//
	// TSDoc:
	// Generates a random question.
	questionMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// quoteMethod is the go binding for the JavaScript quote method.
	//
	// TSDoc:
	// Generates a random quote from a random person.
	quoteMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value
}

// goLorem is the go representation of the JavaScript Lorem type.
//
// TSDoc:
// API to generate random words, sentences, paragraphs, questions and quotes.
type goLorem interface {
	// paragraphMethod is the go representation of the paragraph method.
	//
	// TSDoc:
	// Generates the given number of paragraphs.
	paragraphMethod(paragraphCountArg int, sentenceCountArg int, wordCountArg int, separatorArg string) (string, error)

	// sentenceMethod is the go representation of the sentence method.
	//
	// TSDoc:
	// Generates a space separated list of words beginning with a capital letter and ending with a period.
	sentenceMethod(wordCountArg int) (string, error)

	// wordMethod is the go representation of the word method.
	//
	// TSDoc:
	// Generates a random word.
	wordMethod() (string, error)

	// questionMethod is the go representation of the question method.
	//
	// TSDoc:
	// Generates a random question.
	questionMethod() (string, error)

	// quoteMethod is the go representation of the quote method.
	//
	// TSDoc:
	// Generates a random quote from a random person.
	quoteMethod() (string, error)
}

// jsLoremAdapter converts goLorem to jsLorem.
type jsLoremAdapter struct {
	adaptee goLorem
}

var _ jsLorem = (*jsLoremAdapter)(nil)

// paragraphMethod is a jsLorem adapter method.
func (self *jsLoremAdapter) paragraphMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.paragraphMethod(int(call.Argument(0).ToInteger()), int(call.Argument(1).ToInteger()), int(call.Argument(2).ToInteger()), call.Argument(3).String())
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// sentenceMethod is a jsLorem adapter method.
func (self *jsLoremAdapter) sentenceMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.sentenceMethod(int(call.Argument(0).ToInteger()))
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// wordMethod is a jsLorem adapter method.
func (self *jsLoremAdapter) wordMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.wordMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// questionMethod is a jsLorem adapter method.
func (self *jsLoremAdapter) questionMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.questionMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// quoteMethod is a jsLorem adapter method.
func (self *jsLoremAdapter) quoteMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.quoteMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// goLoremAdapter converts goja Object to goLorem.
type goLoremAdapter struct {
	adaptee *goja.Object
	vm      *goja.Runtime
}

var _ goLorem = (*goLoremAdapter)(nil)

// paragraphMethod is a paragraph adapter method.
func (self *goLoremAdapter) paragraphMethod(paragraphCountArg int, sentenceCountArg int, wordCountArg int, separatorArg string) (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("paragraph"))
	if !ok {
		return "", fmt.Errorf("%w: paragraph", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// sentenceMethod is a sentence adapter method.
func (self *goLoremAdapter) sentenceMethod(wordCountArg int) (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("sentence"))
	if !ok {
		return "", fmt.Errorf("%w: sentence", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// wordMethod is a word adapter method.
func (self *goLoremAdapter) wordMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("word"))
	if !ok {
		return "", fmt.Errorf("%w: word", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// questionMethod is a question adapter method.
func (self *goLoremAdapter) questionMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("question"))
	if !ok {
		return "", fmt.Errorf("%w: question", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// quoteMethod is a quote adapter method.
func (self *goLoremAdapter) quoteMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("quote"))
	if !ok {
		return "", fmt.Errorf("%w: quote", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// jsLoremTo setup Lorem JavaScript object from jsLorem.
func jsLoremTo(src jsLorem, obj *goja.Object, vm *goja.Runtime) error {
	if err := obj.Set("paragraph", src.paragraphMethod); err != nil {
		return err
	}

	if err := obj.Set("sentence", src.sentenceMethod); err != nil {
		return err
	}

	if err := obj.Set("word", src.wordMethod); err != nil {
		return err
	}

	if err := obj.Set("question", src.questionMethod); err != nil {
		return err
	}

	return obj.Set("quote", src.quoteMethod)
}

// jsLoremFrom returns a jsLorem based on a goLorem.
func jsLoremFrom(adaptee goLorem) jsLorem {
	return &jsLoremAdapter{adaptee: adaptee}
}

// goLoremFrom returns a goLorem from goja Object.
func goLoremFrom(adaptee *goja.Object, vm *goja.Runtime) goLorem {
	return &goLoremAdapter{adaptee: adaptee, vm: vm}
}

// goLoremToObject returns a goja Object from goLorem.
func goLoremToObject(v goLorem, vm *goja.Runtime) *goja.Object {
	obj := vm.NewObject()

	err := jsLoremTo(jsLoremFrom(v), obj, vm)
	if err != nil {
		panic(err)
	}

	return obj
}
func goTimeFromDate(v goja.Value, vm *goja.Runtime) time.Time {
	getTime, ok := goja.AssertFunction(v.ToObject(vm).Get("getTime"))
	if !ok {
		panic(fmt.Errorf("%w: getTime", errors.ErrUnsupported))
	}

	ret, err := getTime(v)
	if err != nil {
		panic(err)
	}

	return time.UnixMilli(ret.ToInteger())
}

func jsDateFromTime(t time.Time, vm *goja.Runtime) goja.Value {
	d, err := vm.New(vm.Get("Date"), vm.ToValue(t.UnixMilli()))
	if err != nil {
		panic(err)
	}

	return d
}
