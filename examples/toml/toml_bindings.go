// Code generated by tygor; DO NOT EDIT.

/*
xk6-toml enables k6 tests to comfortably encode and decode TOML values.

## Usage

Import an entire module's contents:
```JavaScript
import * as TOML from "k6/x/toml";
```

Import a single export from a module:
```JavaScript
import { parse } from "k6/x/toml";
```
*/
package toml

import (
	"errors"
	"fmt"
	"github.com/dop251/goja"
	"go.k6.io/k6/js/modules"
	"time"
)

// k6Module represents k6 JavaScript extension module.
type k6Module struct {
	goModuleConstructor goModuleConstructor
}

// NewModuleInstance creates new per VU module instance.
func (m *k6Module) NewModuleInstance(vu modules.VU) modules.Instance {
	mi := new(k6ModuleInstance)
	adaptee := m.goModuleConstructor(vu)
	adapter := jsModuleFrom(adaptee)

	vm := vu.Runtime()

	dict := make(map[string]interface{})

	dict["parse"] = vm.ToValue(adapter.parseMethod)
	dict["stringify"] = vm.ToValue(adapter.stringifyMethod)

	mi.exports.Named = dict

	obj := vm.NewObject()

	mi.exports.Default = obj

	return mi
}

// register registers k6 JavaScript extension module.
func register(ctor goModuleConstructor) {
	m := new(k6Module)
	m.goModuleConstructor = ctor
	modules.Register("k6/x/toml", m)
}

// k6ModuleInstance represents per VU module instance.
type k6ModuleInstance struct {
	exports modules.Exports
}

// Exports returns exported symbols.
func (mi *k6ModuleInstance) Exports() modules.Exports {
	return mi.exports
}

// jsModule is the go binding for the JavaScript Module type.
//
// TSDoc:
// xk6-toml enables k6 tests to comfortably encode and decode TOML values.
//
// ## Usage
//
// Import an entire module's contents:
// ```JavaScript
// import * as TOML from "k6/x/toml";
// ```
//
// Import a single export from a module:
// ```JavaScript
// import { parse } from "k6/x/toml";
// ```
type jsModule interface {
	// parseMethod is the go binding for the JavaScript parse method.
	//
	// TSDoc:
	// The parse() method parses a TOML string, constructing the JavaScript object described by the string.
	parseMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value

	// stringifyMethod is the go binding for the JavaScript stringify method.
	//
	// TSDoc:
	// The stringify() method converts a JavaScript object to a TOML string.
	stringifyMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value
}

// jsModuleAdapter converts goModule to jsModule.
type jsModuleAdapter struct {
	adaptee goModule
}

var _ jsModule = (*jsModuleAdapter)(nil)

// parseMethod is a jsModule adapter method.
func (self *jsModuleAdapter) parseMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.parseMethod(call.Argument(0).String())
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// stringifyMethod is a jsModule adapter method.
func (self *jsModuleAdapter) stringifyMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.stringifyMethod(call.Argument(0).Export())
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// jsModuleFrom returns a jsModule based on a goModule.
func jsModuleFrom(adaptee goModule) jsModule {
	return &jsModuleAdapter{adaptee: adaptee}
}

// goModule is the go representation of the JavaScript Module type.
//
// TSDoc:
// xk6-toml enables k6 tests to comfortably encode and decode TOML values.
//
// ## Usage
//
// Import an entire module's contents:
// ```JavaScript
// import * as TOML from "k6/x/toml";
// ```
//
// Import a single export from a module:
// ```JavaScript
// import { parse } from "k6/x/toml";
// ```
type goModule interface {
	// parseMethod is the go representation of the parse method.
	//
	// TSDoc:
	// The parse() method parses a TOML string, constructing the JavaScript object described by the string.
	parseMethod(textArg string) (interface{}, error)

	// stringifyMethod is the go representation of the stringify method.
	//
	// TSDoc:
	// The stringify() method converts a JavaScript object to a TOML string.
	stringifyMethod(valueArg interface{}) (string, error)
}

// goModuleConstructor creates new goModule instance.
type goModuleConstructor func(vu modules.VU) goModule

func goTimeFromDate(v goja.Value, vm *goja.Runtime) time.Time {
	getTime, ok := goja.AssertFunction(v.ToObject(vm).Get("getTime"))
	if !ok {
		panic(fmt.Errorf("%w: getTime", errors.ErrUnsupported))
	}

	ret, err := getTime(v)
	if err != nil {
		panic(err)
	}

	return time.UnixMilli(ret.ToInteger())
}

func jsDateFromTime(t time.Time, vm *goja.Runtime) goja.Value {
	d, err := vm.New(vm.Get("Date"), vm.ToValue(t.UnixMilli()))
	if err != nil {
		panic(err)
	}

	return d
}
